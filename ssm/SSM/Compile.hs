{- | Compile an SSM program to C code. The generated C code targets a runtime
system that can be found in the @runtime/@ folder.

Each procedure in a program is turned into three components:

1) A struct (the activation record)
2) An initialization function (the enter function)
3) A step function, which corresponds to the actual procedure body

At the moment there is also a @void main(void)@ function being generated, but this is
a specific @main@ that's supposed to be used with the trace platform. The code generator
should be modified in such a way that it does not generate main functions. These should
be written by hand and placed in the different platform directories. The main function
should call functions that are generated by the compiler.

Right now what you can do is to load this module into ghci and issue

>>> writeFile "somename.c" $ toC program

Which will give you a C-file that contains your program. Now you can manually place this
where it needs to go, until we finish the end-to-end compiler pipeline.

-}
module SSM.Compile where

import SSM.Core.Syntax

import SSM.Backend.C.Compile

{- | Compile a program to a C-file
These parameters should be broken out and handled differently. -}
toC :: SSMProgram a => a -> Bool -> Maybe Int -> String
toC p b mi = compile (toProgram p) b mi

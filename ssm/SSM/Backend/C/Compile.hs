module SSM.Backend.C.Compile
    ( -- * Code generation
      {- | A C file representing an entire SSM program can be generated by invoking
      the function @compile@. Right now the function takes two extra parameters,
      aside from the program itself. The first parameter is a @Bool@ which
      specifies if a C main-procedure should be generated, and the second integer,
      if any, specified how many output entries this main should emit. These parameters
      are both tightly related to the @trace@ platform, and should be handled
      differently once we parameterise this function on the target we wish to generate
      code for (but the best thing is probably to not generate target-specific main
      procedures). -}
      compile
    ) where

import SSM.Core.Syntax
import SSM.Backend.C.CodeGen
import SSM.Backend.C.MainLoop

import Data.List ( nub )

import           Text.PrettyPrint.Mainland      ( pretty )
import           Text.PrettyPrint.Mainland.Class
                                                ( pprList )

{- | Compile a program. The bool parameter determines if you want to generate a main
function for testing purposes, and the Maybe Int specifies how many debug items you want
the generated program to output. -}
compile :: Program -> Bool -> Maybe Int -> String
compile p b mi = pretty 120 $ pprList compilationUnit
  where
      compilationUnit = nub includes ++ prg ++ m

      (prg, includes) = compile_ p
      m               = if b then genMain p mi else []

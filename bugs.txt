** Bugs I found with the generator **

1) It generated this program

Procedure fun1
Argument var1
If False
Then
Else
Result ()

Procedure main
Fork [
       fun1((1 + -1))
     ]
Result ()

Which of course makes no sense. However, the C code inflooped where it was supposed to be able to
handle it anyway. The problem was the code generator. When a process is forked it is placed in the
ready queue and then the current process will increment its program counter and return, yielding to
the new forked process. However, forking only works like this if you fork more than one process. If
you are forking only one process the new process will be immediately called by the current process. The
call will not return before the child is run, so there is no chance for the parent to increment its
program counter. The fix was to make sure that if only one process is forked, the program counter
is incremented before the call, while if more than one process is forked the program counter should
be incremented after they are forked.

2)

Function prototypes were for some programs generated in the wrong place, namely after their first
reference point. The fix was to collect all structs and function prototypes during code generation and
make sure that they are the first thing that appears in the C file.

3)

I was pattern-matching only on the scenario where BinderAnn had captured variable names for us. I
had to add the more general pattern and make sure to generate fresh names if BinderAnn hasn't run,
which is the case with the generator.

4)

I had nonexhaustive-patterns in the part of the interpreter that evaluated expressions. I Had to
finish the function definition.

5)

The interpreter would infinitely loop if a program does not terminate. In order to be able to
cease execution if needed I rewrote it to give output lazily instead. It still infinitely loops but
I don't have to wait for the computation to finish before I get the output.

6)

When I implemented the interpreter I did not consider a variable 'written' when it was created,
so if I create a reference r and then check @r, the result would be false. It appears that the
RTS considers variables to be written to in the same instant where they are created, so I changed
the interpreter to act accordingly.

** Bugs I found after changing the AST to be more easily manipulated **

7)

I had forgotten to include a return statement in the generated enter function, resulting in the
scheduler throwing an assertion error. Caught by a generated program.

8)

I had wrongly specified the output format of the generated c code program, so the result parser
did not work properly.

9)

Bug in the code generator where returns where not inserter properly at all places. Whenever the program
should block it needs to return, pending future rescheduling into the readyqueue. This is the program
the produced the bug:

Program {main = "fun2", args = [Right ("ref1",Ref TInt),Left (-1 < 1),Right ("ref3",Ref TBool)],

funs = fromList [("fun1",

Procedure {name = "fun1", arguments = [], body = [ If (3 == -1)
                                                    [Fork [("fun1",[]),("fun1",[])]]
                                                    [Fork [("fun1",[])]]
                                                 , If ((1 - 1) < (- -1))
                                                    [If (0 < 0) [] []]
                                                    [If False 
                                                      []
                                                      []
                                                    ]
                                                 ]}),("fun2",
Procedure {name = "fun2", arguments = [("ref1",Ref TInt),("var2",TBool),("ref3",Ref TBool)],
      body = [ If ((1 * 3) < (-2 - 0))
                 [NewRef (Fresh "v0") (Ref TBool) ((-3 == -1) == (0 < 2))]
                 [Wait [("ref1",Ref TInt)]]
             , After ((-3 * -3) + 1) ("ref3",Ref TBool) (-1 < 1)
             , NewRef (Fresh "v1") (Ref TInt) ((- 3) * (-2 + 2))
             ]})]}

In fun2 the second branch in the if-statement is chosen, but rather than blocking there the codegenerator
just kept on evaluating everything after the if. Clearly an issue.

10)

Found bug in the interpreter where I had forgotten to make the interpreter output the final result
of the input variables once the program had finished executiing. The traces between the two different
runs did not share the same suffix.

11)

Found a bug in the interpreter where it did not print the outputreferences in the end properly. It
only worked if the process the program started evaluating first was also the last one to be
evaluated before the program terminated. If the last statement executed by any process in the
program is a blocking one, and the entrypoint was not in the readyqueue, it would not print the
state of the inputreferences properly.
** Bugs I found with the generator **

1) It generated this program

Procedure fun1
Argument var1
If False
Then
Else
Result ()

Procedure main
Fork [
       fun1((1 + -1))
     ]
Result ()

Which of course makes no sense. However, the C code inflooped where it was supposed to be able to
handle it anyway. The problem was the code generator. When a process is forked it is placed in the
ready queue and then the current process will increment its program counter and return, yielding to
the new forked process. However, forking only works like this if you fork more than one process. If
you are forking only one process the new process will be immediately called by the current process. The
call will not return before the child is run, so there is no chance for the parent to increment its
program counter. The fix was to make sure that if only one process is forked, the program counter
is incremented before the call, while if more than one process is forked the program counter should
be incremented after they are forked.

2)

Function prototypes were for some programs generated in the wrong place, namely after their first
reference point. The fix was to collect all structs and function prototypes during code generation and
make sure that they are the first thing that appears in the C file.

3)

I was pattern-matching only on the scenario where BinderAnn had captured variable names for us. I
had to add the more general pattern and make sure to generate fresh names if BinderAnn hasn't run,
which is the case with the generator.

4)

I had nonexhaustive-patterns in the part of the interpreter that evaluated expressions. I Had to
finish the function definition.

5)

The interpreter would infinitely loop if a program does not terminate. In order to be able to
cease execution if needed I rewrote it to give output lazily instead. It still infinitely loops but
I don't have to wait for the computation to finish before I get the output.

6)

When I implemented the interpreter I did not consider a variable 'written' when it was created,
so if I create a reference r and then check @r, the result would be false. It appears that the
RTS considers variables to be written to in the same instant where they are created, so I changed
the interpreter to act accordingly.

** Bugs I found after changing the AST to be more easily manipulated **

7)

I had forgotten to include a return statement in the generated enter function, resulting in the
scheduler throwing an assertion error. Caught by a generated program.

8)

I had wrongly specified the output format of the generated c code program, so the result parser
did not work properly.

9)

Bug in the code generator where returns where not inserter properly at all places. Whenever the program
should block it needs to return, pending future rescheduling into the readyqueue. This is the program
the produced the bug:

Program {main = "fun2", args = [Right ("ref1",Ref TInt),Left (-1 < 1),Right ("ref3",Ref TBool)],

funs = fromList [("fun1",

Procedure {name = "fun1", arguments = [], body = [ If (3 == -1)
                                                    [Fork [("fun1",[]),("fun1",[])]]
                                                    [Fork [("fun1",[])]]
                                                 , If ((1 - 1) < (- -1))
                                                    [If (0 < 0) [] []]
                                                    [If False 
                                                      []
                                                      []
                                                    ]
                                                 ]}),("fun2",
Procedure {name = "fun2", arguments = [("ref1",Ref TInt),("var2",TBool),("ref3",Ref TBool)],
      body = [ If ((1 * 3) < (-2 - 0))
                 [NewRef (Fresh "v0") (Ref TBool) ((-3 == -1) == (0 < 2))]
                 [Wait [("ref1",Ref TInt)]]
             , After ((-3 * -3) + 1) ("ref3",Ref TBool) (-1 < 1)
             , NewRef (Fresh "v1") (Ref TInt) ((- 3) * (-2 + 2))
             ]})]}

In fun2 the second branch in the if-statement is chosen, but rather than blocking there the codegenerator
just kept on evaluating everything after the if. Clearly an issue.

10)

Found bug in the interpreter where I had forgotten to make the interpreter output the final result
of the input variables once the program had finished executiing. The traces between the two different
runs did not share the same suffix.

11)

Found a bug in the interpreter where it did not print the outputreferences in the end properly. It
only worked if the process the program started evaluating first was also the last one to be
evaluated before the program terminated. If the last statement executed by any process in the
program is a blocking one, and the entrypoint was not in the readyqueue, it would not print the
state of the inputreferences properly.

12)

Found a bug in the codegenerator where the state of the inputreferences to the program was printed
incorrectly. Integers were printed with the formatter %u while it should have been %d.

13)

It managed to shrink a true monster of a program down to this very short one that produced a bug:

Program:
  entrypoint: fun17
  arguments: [Right ("ref9",Ref TBool)]

fun17(("ref9",Ref TBool))
  NewRef (Fresh "v5") (Ref TBool) ((1 < -9) == (1 == 1))
  After ((((- 1) * (1 + 1)) * ((- 1) * (1 + 1))) + 1) ("ref9",Ref TBool) (1 < 1)
  After (((1 * 1) * (1 * 1)) + 1) ("v5",Ref TBool) (1 < 1)
fun3()

After rewriting the expressions to a more readable format we get:

Program:
  entrypoint: fun17
  arguments: [Right ("ref9",Ref TBool)]

fun17(("ref9",Ref TBool))
  NewRef (Fresh "v5") (Ref TBool) false
  After 5 ("ref9",Ref TBool) false
  After 2 ("v5",Ref TBool) false
fun3()

It is easy to see that it should first perform the update at time 2, and then the update at time 5. The
interpreter did it in the other order, meaning there's a bug in the interpreter.

The bug was in the nextEventTime function, which is supposed to return the time of the next event scheduled
to happen.

This is the old version:
-- | Inspects the eventqueue and returns the next event time.
nextEventTime :: Interp s Int
nextEventTime = do
    evs <- gets events
    return $ foldl max 0 (map at evs)

Clearly it does the exact opposite, which is proof that there is more than an insignificant amount of
neanderthal DNA in me. The fix is to get the minimum instead.

return $ foldl min maxBound (map at evs)

14)

Found a bug in the runtime system where an activation record could be deallocated with dangling pointers.
If you register an event on a local variable and then terminate that process, the event will remain
in the event queue while the reference to the variable to update is the same one. The fix is to track
down all local variables in the event queue before deallocating the activation record, and removing
them if there exists any scheduled update. Since we are using a priority queue this incurs a linear time
search through the event queue. Perhaps another data structure is more appropriate.

15)

I found a bug in the interpreter when I ran the following program (e2 inputref):

e1 :: Ref Int64 -> SSM ()
e1 = box "e1" ["ref2"] $ \ref2 -> do
  ref2 <~ (int64 5)
  wait [ref2]
  ref2 <~ (int64 10)

e2 :: Ref Int64 -> SSM ()
e2 = box "e2" ["ref1"] $ \ref1 -> do
  fork [ e1 ref1, e1 ref1 ]

If we start in e2 we will fork two e1, and then they will both block, at which point the program
should terminate as there are no scheduled events and no processes in the ready queue. The interpreter
proceeded past the wait statement instead.

In one place in the report it said that when a variable is written we should only wake up those processes
that are waiting for a update, that have a greater priority than the process that is performing the
update. Here is the patch

writeVar :: Var s -> SSMExp -> Interp s ()
writeVar ref e = do
    (variable,waits, _) <- lift' $ readSTRef ref
    lift' $ writeSTRef variable e -- actually update the variable value

    -- which waiting processes should be woken up? Only those whose priority
    -- is strictly greater than the one who updated the variable
    p <- gets process
    let (towait, keep) = partition (\p' -> priority p < priority p') waits

    -- wake up and desensitize the processes
    mapM_ desensitize towait

    -- update the variable to be written to in this instant and give it knowledge of
    -- which processes are still waiting on it
    lift' $ writeSTRef ref (variable, keep, True)

16)

QuickCheck generated a program like this one

eventorder :: Ref Int -> Ref Int -> SSM ()
eventorder = box "eventorder" ["r1","r2"] $ \r1 r2 -> do
  after 2 r1 5
  after 2 r2 10

The event r1 = 5 should happen first (in the instant) and then r2 = 10. It should not make a difference
I think, but we still want them to do the same thing. The fix was to ensure that events are
inserted in the right order in the interpreter.

schedule_event :: Event s -> Interp s ()
schedule_event e = do
    evs <- gets events
    if any ((==) e) evs
        then let evs' = delete e evs
             in modify $ \st -> st { events = insert e evs' }
        else    modify $ \st -> st { events = insert e evs  }
  where
      insert :: Event s -> [Event s] -> [Event s]
      insert e []       = [e]
      insert e1 (e2:es) =
          if at e1 < at e2
              then e1 : e2 : es
              else e2 : insert e1 es

Right now the two queues are in the interprer just lists that we make sure to insert things into
in an ordered fashion, but there should really be a better datastructure for this. A tree or something.